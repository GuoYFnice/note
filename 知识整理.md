

# 知识整理

## css

### 1.盒模型

- ie盒模型或怪异盒模型（box-sizing：border-box）——content的内容包括padding和border和content

- w3c盒模型（box-sizing：content-box）——width宽度只包含元素的content宽度，总宽度 = width + padding(左右) + border(左右)

### 2.BFC（块级格式上下文）

是一个独立的渲染区域，BFC内部元素与外部元素互相隔离

触发条件

- 根元素
- position：fixed/absolute（脱离文档流)
- float(脱离文档流)
- ovevflow不为visible
- ie浏览器通过zoom：1

通常用来

- 清除浮动
- 自适应两栏布局（左边浮动，右边设置overflow为hidden触发BFC）
- 阻止`margin`重叠

### 3.居中布局

- 水平居中
  1. 行内元素：text-align：center
  2. 块级元素：margin：0 auto
  3. flex：justify-content：center
  4. absolute-transform
- 垂直居中
  1. lineheight：height
  2. absolute-transform
  3. flex：align-content：center
  4. table

- 垂直水平居中
  1. absolute-transform
  2. flex + justify-content + align-items

### 4.选择器优先级

!important>行内样式（style）>id#>class.>*>全局样式>继承

### 5.去除浮动

1. 使用BFC
2. 增加伪元素（：after：clear：both）
3. 父级元素设置行高

### 6.css3新属性

- 边框

  border-radius：圆角边框，border-radius:25px

  box-shadow：边框阴影，box-shadow: 10px 10px 5px#888888

  border-image：边框图片，border-image:url(border.png) 30 30 round;

- 文本效果

  text-shadow：向文本应用阴影，可以规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色

  word-wrap：允许文本进行换行。word-wrap:break-word

- 转换（**transform**）

  translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 transform: translate(50px,100px);

  rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform: rotate(30deg);

  scale()：元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。transform: scale(2,4);

  skew()：元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。transform: skew(30deg,20deg);

  matrix()： 把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。transform:matrix(0.866,0.5,-0.5,0.866,0,0);

- 过度（**transition**）

  transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。

  transition-duration：过渡动画的一个持续时间。

  transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 。

  transition-delay：延迟多久后开始动画。

  简写为：transition: [<transition-property> || <transition-duration> || <transition-timing-function> || <transition-delay>];

- 动画（animation）



### 7.伪类选择器

- +：获取当前元素的相邻的满足条件的元素
- ~：获取当前元素满足条件的兄弟元素
- :first-child :选取属于其父元素的首个子元素的指定选择器
- :last-child :选取属于其父元素的最后一个子元素的指定选择器
- :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型
- :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。
  n 可以是数字、关键词或公式,even偶数，odd奇数
- :first-of-type ：选择属于其父元素的首个元素的每个元素
- :last-of-type ：选择属于其父元素的最后元素的每个元素
- :nth-of-type ：选择属于其父元素第n个元素的每个元素

### 8.伪元素

- ::before
- ::after
- ::first-letter——选中块级元素第一行的第一个字母，最前面为图片或内联的表格时会干扰选择
- ::first-line——选中块级元素中第一行。
- ::selection——选中被用户高亮选择的部分；可以不配合其他元素使用，只有一小部分的 CSS 属性可用于此选择器：

### 9.flex（弹性布局）

使用display:flex设置，对盒子的属性如下

- ### flex-direction

  决定主轴的方向，

  ```css
    flex-direction: row | row-reverse | column | column-reverse;
  ```

- ### flex-wrap

  决定是否换行

  ```css
  flex-wrap: nowrap | wrap | wrap-reverse;
  ```

- ### flex-flow

  为flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap

- ###  justify-content

  定义了项目在主轴上的对齐方式。

  ```css
  justify-content: flex-start | flex-end | center | space-between | space-around;
  ```

- ###  align-items

  在交叉轴上如何对齐

  ```css
  align-items: flex-start | flex-end | center | baseline | stretch;
  ```

  `baseline`: 项目的第一行文字的基线对齐。

  `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度

- ### align-content

  定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

  ```css
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
  ```

对盒子内部项目的属性如下

- ### order

  定义项目的排列顺序。数值越小，排列越靠前，默认为0。

  ```css
  order: <integer>;
  ```

- ### flex-grow

  定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大

  如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

- ### flex-shrink

  义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

- ### flex-basis

  定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。

  ```css
  flex-basis: <length> | auto; /* default auto */
  ```

  它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间

- ###  flex

  `flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。

  ```css
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
  ```

- ###  align-self

  允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

  ```css
   align-self: auto | flex-start | flex-end | center | baseline | stretch;
  ```

### 10.grid（网格布局）

`display: grid`指定一个容器采用网格布局。

display: inline-grid是在行内的一个网络布局

- #### 盒子属性

#### grid-template-columns 属性， grid-template-rows 属性

容器指定了网格布局以后，接着就要划分行和列。`grid-template-columns`属性定义每一列的列宽，`grid-template-rows`属性定义每一行的行高。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;//也可以使用%
  grid-template-rows: 100px 100px 100px;
}
```

- repeat
  grid-template-columns: repeat(3, 33.33%);
  grid-template-rows: repeat(3, 33.33%);
  有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。
  接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。

- auto-fill
  元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充

- fr

  为了方便表示比例关系，网格布局提供了`fr`关键字（fraction 的缩写，意为"片段"）。如果两列的宽度分别为`1fr`和`2fr`，就表示后者是前者的两倍。

- minmax()

  `minmax()`函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。
grid-template-columns: 1fr 1fr minmax(100px, 1fr);
  上面代码中，`minmax(100px, 1fr)`表示列宽不小于`100px`，不大于`1fr`
  
- auto

  `auto`关键字表示由浏览器自己决定长度。

  ```css
  grid-template-columns: 100px auto 100px;
  ```

  上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了`min-width`，且这个值大于最大宽度。

- 网格线的名称

  `grid-template-columns`属性和`grid-template-rows`属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。

  > ```css
  > .container {
  >   display: grid;
  >   grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
  >   grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];
  > }
  > ```

  上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。

  网格布局允许同一根线有多个名字，比如`[fifth-line row-5]`。

#### grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性

`grid-row-gap`属性设置行与行的间隔（行间距），`grid-column-gap`属性设置列与列的间隔（列间距）。

```css
.container {
  grid-row-gap: 20px;
  grid-column-gap: 20px;
}
```

`grid-gap`属性是`grid-column-gap`和`grid-row-gap`的合并简写形式，语法如下。

```
grid-gap: <grid-row-gap> <grid-column-gap>;
```



#### grid-template-areas 

网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: 'a b c'
                       'd e f'
                       'g h i';
}
```

上面代码先划分出9个单元格，然后将其定名为`a`到`i`的九个区域，分别对应这九个单元格。

如果某些区域不需要利用，则使用"点"（`.`）表示。

注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为`区域名-start`，终止网格线自动命名为`区域名-end`。

比如，区域名为`header`，则起始位置的水平网格线和垂直网格线叫做`header-start`，终止位置的水平网格线和垂直网格线叫做`header-end`。

#### grid-auto-flow

划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行

默认值是`row`，即"先行后列"。也可以将它设成`column`，变成"先列后行"。

`grid-auto-flow`属性除了设置成`row`和`column`，还可以设成`row dense`和`column dense`。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置

#### justify-items 属性， align-items 属性， place-items 属性

`justify-items`属性设置单元格内容的水平位置（左中右），`align-items`属性设置单元格内容的垂直位置（上中下）。

```css
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
```

`place-items`属性是`align-items`属性和`justify-items`属性的合并简写形式。

```css
place-items: <align-items> <justify-items>;
```

#### justify-content 属性， align-content 属性， place-content 属性

`justify-content`属性是整个内容区域在容器里面的水平位置（左中右），`align-content`属性是整个内容区域的垂直位置（上中下）。

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
```

`place-content`属性是`align-content`属性和`justify-content`属性的合并简写形式。

#### grid-auto-columns 属性， grid-auto-rows 属性

`grid-auto-columns`属性和`grid-auto-rows`属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与`grid-template-columns`和`grid-template-rows`完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。

#### grid-template 属性， grid 属性

`grid-template`属性是`grid-template-columns`、`grid-template-rows`和`grid-template-areas`这三个属性的合并简写形式。

`grid`属性是`grid-template-rows`、`grid-template-columns`、`grid-template-areas`、 `grid-auto-rows`、`grid-auto-columns`、`grid-auto-flow`这六个属性的合并简写形式。

- #### 项目属性

#### grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性

- `grid-column-start`属性：左边框所在的垂直网格线
- `grid-column-end`属性：右边框所在的垂直网格线
- `grid-row-start`属性：上边框所在的水平网格线
- `grid-row-end`属性：下边框所在的水平网格线

这四个属性的值还可以使用`span`关键字，表示"跨越"，即左右边框（上下边框）之间跨越多少个网格。

#### grid-column 属性， grid-row 属性

`grid-column`属性是`grid-column-start`和`grid-column-end`的合并简写形式，`grid-row`属性是`grid-row-start`属性和`grid-row-end`的合并简写形式。

####  grid-area

`grid-area`属性指定项目放在哪一个区域

`grid-area`属性还可用作`grid-row-start`、`grid-column-start`、`grid-row-end`、`grid-column-end`的合并简写形式，直接指定项目的位置。

#### justify-self 属性， align-self 属性， place-self 属性

`justify-self`属性设置单元格内容的水平位置（左中右），跟`justify-items`属性的用法完全一致，但只作用于单个项目。

`align-self`属性设置单元格内容的垂直位置（上中下），跟`align-items`属性的用法完全一致，也是只作用于单个项目。

```css
.item {
  justify-self: start | end | center | stretch;
  align-self: start | end | center | stretch;
}
```





















## JavaScript

### 1.原型-原型链

![image-20191231153103165](C:\Users\60377\AppData\Roaming\Typora\typora-user-images\image-20191231153103165.png)

- 构造函数

  可以通过`new`来 **新建一个对象** 的函数。

- 原型对象

  一个简单的对象，用于实现对象的 **属性继承**。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个`JavaScript`对象中都包含一个`__proto__` (非标准)的属性指向它爹(该对象的原型)，可`obj.__proto__`进行访问

- 实例

  通过构造函数和`new`创建出来的对象，便是实例。 **实例通过`__proto__`指向原型，通过`constructor`指向构造函数**

```
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型
```

**原型链**

**原型链是由原型对象组成**，每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型，`__proto__` 将对象连接起来组成了原型链。是一个用来**实现继承和共享属性**的有限的对象链。

**属性查找机制**: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象`Object.prototype`，如还是没找到，则输出`undefined`；

**属性修改机制**: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: `b.prototype.x = 2`；但是这样会造成所有继承于该对象的实例的属性发生改变。

### 2.THIS

调用位置——  调用位置就是函数在代码中被调用的位置  

最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的
调用位置就在当前正在执行的函数的前一个调用中  

```javascript
function baz(){
//当前的调用栈是baz
//因此调用位置是全局作用域
    console.log('baz')
    bar()  //bar的调用位置
}
function bar(){bar
//当前的调用栈是baz -> bar
//因此调用位置是baz
    console.log('bar')
    foo()  //foo的调用位置
}
function foo(){
//当前的调用栈是baz -> bar -> foo
//因此调用位置是bar
    console.log('foo')
}
baz()  //baz的调用位置
```



绑定规则

1、默认绑定

```javascript
function foo(){
	console.log(this.a)
}
var a = 2 
foo() //2
```

那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调
用的。在代码中， foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用
默认绑定，无法应用其他规则。  

2、隐式绑定

```javascript
function foo(){
	console.log(this.a)
}
var obj = {
	a:2,
    foo:foo
}
obj.foo() //2
```

调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥
有”或者“包含”它。当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引
用有上下文对象时， 隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调
用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的  

3、显式绑定

```javascript
function foo(){
	console.log(this.a)
}
var obj = {
	a:2
}
foo.call(obj) //2
```

4、new绑定

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。

1. 创建（或者说构造）一个全新的对象。
2. 这个新对象会被执行 [[ 原型 ]] 连接。
3. 这个新对象会绑定到函数调用的 this。
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。  

优先级

默认绑定最低的

显示绑定大于隐式绑定

new绑定大于隐式绑定

1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。
   var bar = new foo()
2. 函数是否通过 call、 apply（显式绑定）或者硬绑定调用？如果是的话， this 绑定的是
   指定的对象。
   var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上
   下文对象。
   var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到
   全局对象。
   var bar = foo()  

### 3.let  /  const  /  var

let,const用于声明变量，用来替代老语法的var关键字，与var不同的是，let/const会创建一个块级作用域（通俗讲就是一个花括号内是一个新的作用域）

- let

  不存在变量提升，如果在还未声明是使用会报错ReferenceError

- const

  const声明变量的时候必须赋值，否则会报错，同样使用const声明的变量被修改了也会报错

  const声明变量不能改变，如果声明的是一个引用类型，则不能改变它的内存地址

### 4.数据类型

#### 7种简单的数据类型

- Undefined
- Null
- Boolean
- Number
- String
- Symbol
- BigInt (ES10 草案)

#### 1种复杂数据类型

- Object（Function 是 Object 的子类，即继承于 Object）

#### 判断数据类型

1. Object.prototype.toString.call()可以鉴别所有的类型  结果为[object ,object ],[object Undefined]

2. instanceof

   `instanceof`  的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

   使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

   但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true

3. typeof

   只对基本类型有用。但不包括null（因为js的所有对象在底层都是二进制的，js把前三位为0的表示为object，null全为0）
   
   - 对于基本类型，除 null 以外，均可以返回正确的结果。
   - 对于引用类型，除 function 以外，一律返回 object 类型。
   - 对于 null ，返回 object 类型。
   - 对于 function 返回  function 类型。

基本类型存放在栈中。对象数据类型存放在堆中。

对于`赋值`操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。

#### 深拷贝|浅拷贝

当变量复制引用类型值的时候，同样和基本类型值一样会将变量的值复制到新变量上，不同的是对于变量的值，它是一个指针，指向存储在堆内存中的对象（JS规定放在堆内存中的对象无法直接访问，必须要访问这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，所以引用类型的值是按引用访问）

- 浅拷贝

  1. Object.assign

     ES6中拷贝对象的方法，接受的第一个参数是拷贝的目标，剩下的参数是拷贝的源对象（可以是多个）

  2. 拓展运算符

  3. Array.prototype.slice

  4. Array.prototype.concat

- 深拷贝

  1. JSON.parse（JSON.stringify）

     如果obj里面有时间对象，时间将只是字符串的形式。而不是时间对象；

     如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；

     如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；

     如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null

  2. 递归

     递归地狱回调可以通过return的方法解决

#### undefined与null的区别

`undefined` 是 `Undefined` 类型的值，表示未定义。任何变量在赋值前都是 `Undefined` 类型，值为 `undefined` 。由于`undefined` 只是全局作用域下的一个属性（变量），并非关键字。`undefined` **属性的属性特性** ,而在函数作用域内是可以随意改写 `undefined` 的。这也是建议使用 **`void 0` 来表示 `undefined` 的来源**

`Null` 类型也只有一个值，就是 `null`，它的语义表示空值，与 `undefined` 不同，`null` 是 `JavaScript` 关键字，所以在任何代码中，你都可以放心用 `null` 关键字来获取 `null` 值。

#### 拆箱转换

在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。

拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。String 类型会优先调用 toString ;

### 5.隐式转换

涉及最多的两个操作符+ ==

\- * / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型

隐式转换中主要涉及到三种转换：

1、将值转为原始值，ToPrimitive()。

2、将值转为数字，ToNumber()。

3、将值转为字符串，ToString()。

### 6.

### 7.箭头函数

### 8.

### 9.







## 计算机网络

### 应用层

应用层规定了向用户提供应用服务时通信的协议，如：

TCP/IP 协议族内预存了各类通用的应用服务协议。比如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中的两类以及HTTP协议。

### 传输层

传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议。

在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。

TCP协议是全双工的，即发送数据和接收数据是同步进行的，就好像我们打电话一样，说话的同时也能听见。TCP协议在建立和断开连接时有三次握手和四次挥手，因此在传输的过程中更稳定可靠但同时就没UDP那么高效了。

UDP协议是面向无连接的，也就是说在正式传递数据之前不需要先建立连接。UDP 协议不保证有序且不丢失的传递到对端，也就是说不够稳定，但也正因如此，UDP协议比TCP更加高效和轻便。

### 网络层

网络层规定了数据通过怎样的传输路线到达对方计算机传送给对方（IP协议等）。

与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的所用就是在众多的选项内选择一条传输路线。就跟携程提供的回家路线图作用一样。

### 数据链路层

用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

### 物理层

光猫等设备



### 状态码

HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。

| 2XX  | 成功（这系列表明请求被正常处理了）                     |
| ---- | ------------------------------------------------------ |
| 200  | OK，表示从客户端发来的请求在服务器端被正确处理         |
| 204  | No content，表示请求成功，但响应报文不含实体的主体部分 |
| 206  | Partial Content，进行范围请求成功                      |

| 3XX  | 重定向（表明浏览器要执行特殊处理）                           |
| ---- | ------------------------------------------------------------ |
| 301  | moved permanently，永久性重定向，表示资源已被分配了新的 URL  |
| 302  | found，临时性重定向，表示资源临时被分配了新的 URL            |
| 303  | see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求） |
| 304  | not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关） |
| 307  | temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 |

| 4XX  | 客户端错误                                                   |
| ---- | ------------------------------------------------------------ |
| 400  | bad request，请求报文存在语法错误                            |
| 401  | unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息   |
| 403  | forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述 |
| 404  | not found，表示在服务器上没有找到请求的资源                  |

| 5XX  | 服务器错误                                                   |
| ---- | ------------------------------------------------------------ |
| 500  | internal sever error，表示服务器端在执行请求时发生了错误     |
| 501  | Not Implemented，表示服务器不支持当前请求所需要的某个功能    |
| 503  | service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 |

   

### 首部字段

下面是请求首部和响应首部中的字段名称和作用：

| 请求首部            | 作用（请求报文专用）                                         |
| ------------------- | ------------------------------------------------------------ |
| Accept              | 能正确接收的媒体类型：`application/json` `text/plain`        |
| Accept-Charset      | 能正确接收的字符集: `unicode-1-1`                            |
| Accept-Encoding     | 能正确接收的编码格式列表：`gzip deflate`                     |
| Accept-Language     | 能正确接收的语言列表：`zh-cn,zh;1=0.9,en,1=0.8`              |
| Authorization       | 客户端认证信息：`Bearer dSdSdFFlsfdjasd123`，一般存token用   |
| Cookie              | 发送给服务器的Cookie信息                                     |
| Expect              | 期待服务端的指定行为                                         |
| From                | 请求方邮箱地址                                               |
| Host                | 服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。 |
| If-Match            | 两端资源标记比较，只有判断条件为真服务端才会接受请求：`If-Mach: "123456`，和服务端文件标记比较 |
| If-Modified-Since   | 本地资源未修改返回 304（比较时间）                           |
| If-None-Match       | 本地资源未修改返回 304（比较标记）                           |
| User-Agent          | 客户端信息                                                   |
| Max-Forwards        | 限制可被代理及网关转发的次数                                 |
| Proxy-Authorization | 向代理服务器发送验证信息                                     |
| Range               | 请求某个内容的一部分，配合`If-Range`使用                     |
| Referer             | 请求发起页面的原始URI                                        |
| TE                  | 传输编码方式                                                 |

| 响应首部           | 作用（响应报文专用）                                    |
| ------------------ | ------------------------------------------------------- |
| Accept-Ranges      | 告知客户端服务器是否可接受范围请求，是`bytes`，否`none` |
| Age                | 资源在代理缓存中存在的时间                              |
| ETag               | 资源标识，资源发生变化时标识也会发生改变                |
| Location           | 客户端重定向到某个 URL                                  |
| Proxy-Authenticate | 向代理服务器发送验证信息                                |
| Server             | 服务器名字：`Apache Nginx`                              |
| WWW-Authenticate   | 获取资源需要的认证方案                                  |
| Set-Cookie         | 需要存在客户端的信息，一般用于识别用户身份              |

| 实体首部         | 作用（补充请求报文或响应报文相关信息）                       |
| ---------------- | ------------------------------------------------------------ |
| Allow            | 资源的正确请求方式：`GET HEAD POST`                          |
| Content-Encoding | 内容的编码格式：`gzip deflate`                               |
| Content-Language | 内容使用的语言：`zh-CN`                                      |
| Content-Length   | request body 长度（即实体主体的大小）：                      |
| Content-Location | 返回数据的备用地址                                           |
| Content-MD5      | Base64加密格式的内容 MD5检验值                               |
| Content-Range    | 响应主体的内容范围                                           |
| Content-Type     | 内容的媒体类型（如'application/json;charset=UTF-8'则会发送预检请求） |
| Expires          | 内容的过期时间                                               |
| Last_modified    | 内容的最后修改时间                                           |

