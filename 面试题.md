# 每日一题

> 木易杨说的精选大厂前端面试高频 100 题

每天记录一下自己对题的理解和学到的知识

## 1. 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

> key是给每一个vnode的唯一id,可以`依靠key`,更`准确`, 更`快`的拿到oldVnode中对应的vnode节点。

对于vue的diff算法，在进行新旧节点的开始与结束位置的四个节点进行sameVnode比较，若没有则会进行对每一个旧节点的key进行map新节点的key

#####  更准确

因为带key就不是`就地复用`了，在sameNode函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

##### 更快

利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。



## 2. ['1', '2', '3'].map(parseInt) what & why ?

### parselnt()

**这道题先要了解一下parseInt**——用来解析字符串的，使字符串成为指定基数的整数。
`parseInt(string, radix)`
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。该值介于 2 ~ 36 之间。

如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。

如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。

### map

map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

他的callback接受三个参数

| *currentValue* | 必须。当前元素的值           |
| -------------- | ---------------------------- |
| *index*        | 可选。当前元素的索引值       |
| *arr*          | 可选。当前元素属于的数组对象 |

- 运行情况

1. parseInt('1', 0) //这个时候返回1
2. parseInt('2', 1) //（1进制）返回NaN
3. parseInt('3', 2) //（2进制）返回NaN

- map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]



## 3. 什么是防抖和节流？有什么区别？如何实现？

### 防抖

防抖就是高频触发事件**后**在规定时间内只执行一次。如果在规定时间内再次触发，则重新计算时间（后很关键！）

```javascript
function debounce(fn){
    let timeout = null
    return function(){
        clearTimeout(timeout)//将上一个时间清除掉
        let timeout = setTimeout(() => {//重新计算时间
        	fn.apply(this,argument)
        },500)
    }
}
```

###  节流

节流就是在高频触发时间，在规定时间内只执行一次，会稀释函数的执行频率

```javascript
function throttle(fn){
	let do = true
    return function(){
		if(!do){
            return
        }
        do = false
        setTimeout(() => {
            fn.apply(this,argument)
            do = true
        },500)
    }
}
```



## 4.介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

### set

类似数组，但里成员的值是唯一的（可以用来去重）Set是一个构造函数，用来生成一个Set数据结构（可以接受一个数组）

向set加入值时，不会发生类型转换，所以5 ‘5’不同，但是NaN只能加入一个(在set里面NaN是相同的，但是在js里面NaN===NaN is false！！！两个对象永远是不相等的)

```javascript
const a = new Set()
const b = new Set([1,1,2,3,4,4,2,6])
a.add(1)//加入
a.size//成员数
a.has(1)//是否有该成员
a.delete(1)//删除
a.clear()//清除set没有返回值
```

Array.from()可以将Set转变成数组

遍历方法（因为Set没有键名只有键值，所以两个都是一个值）

```javascript
a.keys()//返回键名
a.values()//返回键值   默认的遍历方法
a.entries()//返回键值对
a.forEach()
```

### WeakSet

类似于Set，不能重复的值的集合，但只接受对象

几乎与Set相同

### Map

类似于对象，键值对的集合，各种类型都能当作键“值值对应”

```javascript
const a = new Map()
a.set(o,'a')
a.get(o) //'a'
a.has(o) //true
a.delete(o)
a.size
```

Set和Map都可以用来创建Map

```javascript
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
```

对同一个键赋值，后值覆盖前值

Map在对键进行比较时，比较的是内存地址

遍历方式与Set相同（遍历顺序就是插入顺序）

```javascript
[...Map]//将Map转换为数组
strMapToObj（Map）//将Map转化为对象
objToStrMap（obj）//将对象转化为Map
strMapToJson()//将Map转化为json
jsonToStrMap()//将json转化为Map
```

### WeakMap

`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

`WeakMap`与`Map`的区别有两点。

首先，`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。其次，`WeakMap`的键名所指向的对象，不计入垃圾回收机制。键名弱引用，一旦不使用，则会删除



## 5.  介绍下深度优先遍历和广度优先遍历，如何实现？

### 深度优先遍历

先找一个顶点为初始点v1，先访问v1并且将v1标记为已访问；然后依次访问v1的未被访问的相邻节点v2进行深度优先遍历并且将v2标记为已访问，在对v2的相邻节点进行如果没有则回溯到v1，直到所有的点都被访问。

类似于树的先序遍历（顺便树的三种遍历方式

​	先序遍历：根——左——右

​	中序遍历：左——根——右

​	后序遍历：左——右——跟

）

```javascript
let deepTraversal1 = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node)
    let children = node.children
    for (let i = 0; i < children.length; i++) {
      deepTraversal1(children[i], nodeList)
    }
  }
  return nodeList
}
let deepTraversal2 = (node) => {
    let nodes = []
    if (node !== null) {
      nodes.push(node)
      let children = node.children
      for (let i = 0; i < children.length; i++) {
        nodes = nodes.concat(deepTraversal2(children[i]))
      }
    }
    return nodes
  }
// 非递归
let deepTraversal3 = (node) => {
  let stack = []
  let nodes = []
  if (node) {
    // 推入当前处理的node
    stack.push(node)
    while (stack.length) {
      let item = stack.pop()
      let children = item.children
      nodes.push(item)
      // node = [] stack = [parent]
      // node = [parent] stack = [child3,child2,child1]
      // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]
      // node = [parent, child1-1] stack = [child3,child2,child1-2]
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```

### 广度优先遍历

先找一个顶点为初始点v1，先访问v1并且将v1标记为已访问；然后对v1的所有相邻节点进行访问并标记排序（v2,v3,v4），在对排序中的第一个v2进行广度优先遍历，直到所有的点都被访问。

```javascript
let widthTraversal2 = (node) => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
        // 队列，先进先出
        // nodes = [] stack = [parent]
        // nodes = [parent] stack = [child1,child2,child3]
        // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
        // nodes = [parent,child1,child2]
      for (let i = 0; i < children.length; i++) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```



## 6.请分别用深度优先思想和广度优先思想实现一个拷贝函数？

代码没写

思路：先判断是否为引用类型，对环状数据进行处理

深度优先：先对第一个值进行赋值，判断有无子节点，有——在对他的子节点进行遍历操作，无——返回

广度优先：先对第一个值进行赋值，判断有无子节点，对每一个子节点进行赋值，在对第一个子节点进行判断有无子节点，有——进行所有孙子节点赋值再重复，无——返回，进行第二个子节点

## 

## 7.  ES5/ES6 的继承除了写法以外还有什么区别？

## 8. setTimeout、Promise、Async/Await 的区别

> 事件循环中分为宏任务队列和微任务队列。
> 其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
> promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

### 宏任务

每次执行栈的代码就是一个宏任务。

### 微任务

可以理解是在当前宏任务 执行结束后立即执行的任务

### setTimeout

```javascript
console.log('script start')	//1. 打印 script start
setTimeout(function(){
    console.log('settimeout')	// 4. 打印 settimeout
})	// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数
console.log('script end')	//3. 打印 script start
// 输出顺序：script start->script end->settimeout
```

### Promise

Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行

```javascript
console.log('script start')
let promise1 = new Promise(function (resolve) {
    console.log('promise1')
    resolve()
    console.log('promise1 end')
}).then(function () {
    console.log('promise2')
})
setTimeout(function(){
    console.log('settimeout')
})
console.log('script end')
// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout
```

#### async/await

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

```javascript
async function async1(){
   console.log('async1 start');
    await async2();
    console.log('async1 end')
}
async function async2(){
    console.log('async2')
}

console.log('script start');
async1();
console.log('script end')

// 输出顺序：script start->async1 start->async2->script end->async1 end
```



## 9.Async/Await 如何通过同步的方式实现异步

## 10.  常见异步笔试题 

```javascript
//请写出输出内容
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');


/*
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/
```

执行settimeout（）会在所有的最后面执行

async  如果遇到await 会立刻执行await后面的内容然后跳出，继续执行事件栈内容，等执行完在进行回来执行

promise resolve()会异步执行.then的内容

## 11.  请写出如下代码的打印结果

```javascript
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();

/*
4
2
1
*/
```

在进行第一个Foo.a调用时构造函数Foo还没有声明，所以为4

let obj = new Foo();接着对Foo进行声明。产生实例

```
1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
2. 在新对象上挂载直接方法 a ，输出值为 2。
```